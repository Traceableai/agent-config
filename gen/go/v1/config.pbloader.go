// Code generated by github.com/hypertrace/agent-config/tools/go-generator. DO NOT EDIT.

package v1

import wrappers "google.golang.org/protobuf/types/known/wrapperspb"

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *AgentConfig) loadFromEnv(prefix string, defaultValues *AgentConfig) {
	if x.Opa == nil {
		x.Opa = new(Opa)
	}
	if defaultValues == nil {
		x.Opa.loadFromEnv(prefix+"OPA_", nil)
	} else {
		x.Opa.loadFromEnv(prefix+"OPA_", defaultValues.Opa)
	}

	if x.BlockingConfig == nil {
		x.BlockingConfig = new(BlockingConfig)
	}
	if defaultValues == nil {
		x.BlockingConfig.loadFromEnv(prefix+"BLOCKING_CONFIG_", nil)
	} else {
		x.BlockingConfig.loadFromEnv(prefix+"BLOCKING_CONFIG_", defaultValues.BlockingConfig)
	}

	if val, ok := getBoolEnv(prefix + "DEBUG_LOG"); ok {
		x.DebugLog = &wrappers.BoolValue{Value: val}
	} else if x.DebugLog == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.DebugLog = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.DebugLog != nil {
			x.DebugLog = &wrappers.BoolValue{Value: defaultValues.DebugLog.Value}
		}
	}
	if x.RemoteConfig == nil {
		x.RemoteConfig = new(RemoteConfig)
	}
	if defaultValues == nil {
		x.RemoteConfig.loadFromEnv(prefix+"REMOTE_CONFIG_", nil)
	} else {
		x.RemoteConfig.loadFromEnv(prefix+"REMOTE_CONFIG_", defaultValues.RemoteConfig)
	}

	if x.ApiDiscovery == nil {
		x.ApiDiscovery = new(ApiDiscoveryConfig)
	}
	if defaultValues == nil {
		x.ApiDiscovery.loadFromEnv(prefix+"API_DISCOVERY_", nil)
	} else {
		x.ApiDiscovery.loadFromEnv(prefix+"API_DISCOVERY_", defaultValues.ApiDiscovery)
	}

	if x.Sampling == nil {
		x.Sampling = new(SamplingConfig)
	}
	if defaultValues == nil {
		x.Sampling.loadFromEnv(prefix+"SAMPLING_", nil)
	} else {
		x.Sampling.loadFromEnv(prefix+"SAMPLING_", defaultValues.Sampling)
	}

	if x.Javaagent == nil {
		x.Javaagent = new(Javaagent)
	}
	if defaultValues == nil {
		x.Javaagent.loadFromEnv(prefix+"JAVAAGENT_", nil)
	} else {
		x.Javaagent.loadFromEnv(prefix+"JAVAAGENT_", defaultValues.Javaagent)
	}

	if x.Logging == nil {
		x.Logging = new(LogConfig)
	}
	if defaultValues == nil {
		x.Logging.loadFromEnv(prefix+"LOGGING_", nil)
	} else {
		x.Logging.loadFromEnv(prefix+"LOGGING_", defaultValues.Logging)
	}

	if x.MetricsConfig == nil {
		x.MetricsConfig = new(MetricsConfig)
	}
	if defaultValues == nil {
		x.MetricsConfig.loadFromEnv(prefix+"METRICS_CONFIG_", nil)
	} else {
		x.MetricsConfig.loadFromEnv(prefix+"METRICS_CONFIG_", defaultValues.MetricsConfig)
	}

	if val, ok := getStringEnv(prefix + "ENVIRONMENT"); ok {
		x.Environment = &wrappers.StringValue{Value: val}
	} else if x.Environment == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Environment = new(wrappers.StringValue)
		if defaultValues != nil && defaultValues.Environment != nil {
			x.Environment = &wrappers.StringValue{Value: defaultValues.Environment.Value}
		}
	}
	if val, ok := getStringEnv(prefix + "SERVICE_NAME"); ok {
		x.ServiceName = &wrappers.StringValue{Value: val}
	} else if x.ServiceName == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.ServiceName = new(wrappers.StringValue)
		if defaultValues != nil && defaultValues.ServiceName != nil {
			x.ServiceName = &wrappers.StringValue{Value: defaultValues.ServiceName.Value}
		}
	}
	if x.Reporting == nil {
		x.Reporting = new(Reporting)
	}
	if defaultValues == nil {
		x.Reporting.loadFromEnv(prefix+"REPORTING_", nil)
	} else {
		x.Reporting.loadFromEnv(prefix+"REPORTING_", defaultValues.Reporting)
	}

	if x.DataCapture == nil {
		x.DataCapture = new(DataCapture)
	}
	if defaultValues == nil {
		x.DataCapture.loadFromEnv(prefix+"DATA_CAPTURE_", nil)
	} else {
		x.DataCapture.loadFromEnv(prefix+"DATA_CAPTURE_", defaultValues.DataCapture)
	}

	if rawVals, ok := getArrayStringEnv(prefix + "PROPAGATION_FORMATS"); ok {
		vals := []PropagationFormat{}
		for _, rawVal := range rawVals {
			vals = append(vals, PropagationFormat(PropagationFormat_value[rawVal]))
		}
		x.PropagationFormats = vals
	} else if len(x.PropagationFormats) == 0 && defaultValues != nil && len(defaultValues.PropagationFormats) > 0 {
		x.PropagationFormats = defaultValues.PropagationFormats
	}

	if val, ok := getBoolEnv(prefix + "ENABLED"); ok {
		x.Enabled = &wrappers.BoolValue{Value: val}
	} else if x.Enabled == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Enabled = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.Enabled != nil {
			x.Enabled = &wrappers.BoolValue{Value: defaultValues.Enabled.Value}
		}
	}
	if defaultValues != nil && len(defaultValues.ResourceAttributes) > 0 {
		if x.ResourceAttributes == nil {
			x.ResourceAttributes = make(map[string]string)
		}
		for k, v := range defaultValues.ResourceAttributes {
			// defaults should not override existing resource attributes unless empty
			if _, ok := x.ResourceAttributes[k]; !ok {
				x.ResourceAttributes[k] = v
			}
		}
	}

	if x.Telemetry == nil {
		x.Telemetry = new(Telemetry)
	}
	if defaultValues == nil {
		x.Telemetry.loadFromEnv(prefix+"TELEMETRY_", nil)
	} else {
		x.Telemetry.loadFromEnv(prefix+"TELEMETRY_", defaultValues.Telemetry)
	}

	if x.Goagent == nil {
		x.Goagent = new(GoAgent)
	}
	if defaultValues == nil {
		x.Goagent.loadFromEnv(prefix+"GOAGENT_", nil)
	} else {
		x.Goagent.loadFromEnv(prefix+"GOAGENT_", defaultValues.Goagent)
	}

}

// PutResourceAttributes sets values in the ResourceAttributes map.
func (x *AgentConfig) PutResourceAttributes(m map[string]string) {
	if len(m) == 0 {
		return
	}
	if x.ResourceAttributes == nil {
		x.ResourceAttributes = make(map[string]string)
	}
	for k, v := range m {
		x.ResourceAttributes[k] = v
	}
}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *Reporting) loadFromEnv(prefix string, defaultValues *Reporting) {
	if val, ok := getStringEnv(prefix + "ENDPOINT"); ok {
		x.Endpoint = &wrappers.StringValue{Value: val}
	} else if x.Endpoint == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Endpoint = new(wrappers.StringValue)
		if defaultValues != nil && defaultValues.Endpoint != nil {
			x.Endpoint = &wrappers.StringValue{Value: defaultValues.Endpoint.Value}
		}
	}
	if val, ok := getBoolEnv(prefix + "SECURE"); ok {
		x.Secure = &wrappers.BoolValue{Value: val}
	} else if x.Secure == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Secure = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.Secure != nil {
			x.Secure = &wrappers.BoolValue{Value: defaultValues.Secure.Value}
		}
	}
	if val, ok := getStringEnv(prefix + "TOKEN"); ok {
		x.Token = &wrappers.StringValue{Value: val}
	} else if x.Token == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Token = new(wrappers.StringValue)
		if defaultValues != nil && defaultValues.Token != nil {
			x.Token = &wrappers.StringValue{Value: defaultValues.Token.Value}
		}
	}
	if rawVal, ok := getStringEnv(prefix + "TRACE_REPORTER_TYPE"); ok {
		x.TraceReporterType = TraceReporterType(TraceReporterType_value[rawVal])
	} else if x.TraceReporterType == TraceReporterType(0) && defaultValues != nil && defaultValues.TraceReporterType != TraceReporterType(0) {
		x.TraceReporterType = defaultValues.TraceReporterType
	}

	if val, ok := getStringEnv(prefix + "CERT_FILE"); ok {
		x.CertFile = &wrappers.StringValue{Value: val}
	} else if x.CertFile == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.CertFile = new(wrappers.StringValue)
		if defaultValues != nil && defaultValues.CertFile != nil {
			x.CertFile = &wrappers.StringValue{Value: defaultValues.CertFile.Value}
		}
	}
	if val, ok := getStringEnv(prefix + "METRIC_ENDPOINT"); ok {
		x.MetricEndpoint = &wrappers.StringValue{Value: val}
	} else if x.MetricEndpoint == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.MetricEndpoint = new(wrappers.StringValue)
		if defaultValues != nil && defaultValues.MetricEndpoint != nil {
			x.MetricEndpoint = &wrappers.StringValue{Value: defaultValues.MetricEndpoint.Value}
		}
	}
	if rawVal, ok := getStringEnv(prefix + "METRIC_REPORTER_TYPE"); ok {
		x.MetricReporterType = MetricReporterType(MetricReporterType_value[rawVal])
	} else if x.MetricReporterType == MetricReporterType(0) && defaultValues != nil && defaultValues.MetricReporterType != MetricReporterType(0) {
		x.MetricReporterType = defaultValues.MetricReporterType
	}

	if val, ok := getBoolEnv(prefix + "ENABLE_GRPC_LOADBALANCING"); ok {
		x.EnableGrpcLoadbalancing = &wrappers.BoolValue{Value: val}
	} else if x.EnableGrpcLoadbalancing == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.EnableGrpcLoadbalancing = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.EnableGrpcLoadbalancing != nil {
			x.EnableGrpcLoadbalancing = &wrappers.BoolValue{Value: defaultValues.EnableGrpcLoadbalancing.Value}
		}
	}
	if val, ok := getStringEnv(prefix + "AGENT_TOKEN"); ok {
		x.AgentToken = &wrappers.StringValue{Value: val}
	} else if x.AgentToken == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.AgentToken = new(wrappers.StringValue)
		if defaultValues != nil && defaultValues.AgentToken != nil {
			x.AgentToken = &wrappers.StringValue{Value: defaultValues.AgentToken.Value}
		}
	}
}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *Opa) loadFromEnv(prefix string, defaultValues *Opa) {
	if val, ok := getBoolEnv(prefix + "ENABLED"); ok {
		x.Enabled = &wrappers.BoolValue{Value: val}
	} else if x.Enabled == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Enabled = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.Enabled != nil {
			x.Enabled = &wrappers.BoolValue{Value: defaultValues.Enabled.Value}
		}
	}
	if val, ok := getStringEnv(prefix + "ENDPOINT"); ok {
		x.Endpoint = &wrappers.StringValue{Value: val}
	} else if x.Endpoint == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Endpoint = new(wrappers.StringValue)
		if defaultValues != nil && defaultValues.Endpoint != nil {
			x.Endpoint = &wrappers.StringValue{Value: defaultValues.Endpoint.Value}
		}
	}
	if val, ok := getInt32Env(prefix + "POLL_PERIOD_SECONDS"); ok {
		x.PollPeriodSeconds = &wrappers.Int32Value{Value: val}
	} else if x.PollPeriodSeconds == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.PollPeriodSeconds = new(wrappers.Int32Value)
		if defaultValues != nil && defaultValues.PollPeriodSeconds != nil {
			x.PollPeriodSeconds = &wrappers.Int32Value{Value: defaultValues.PollPeriodSeconds.Value}
		}
	}
	if val, ok := getStringEnv(prefix + "CERT_FILE"); ok {
		x.CertFile = &wrappers.StringValue{Value: val}
	} else if x.CertFile == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.CertFile = new(wrappers.StringValue)
		if defaultValues != nil && defaultValues.CertFile != nil {
			x.CertFile = &wrappers.StringValue{Value: defaultValues.CertFile.Value}
		}
	}
	if val, ok := getBoolEnv(prefix + "USE_SECURE_CONNECTION"); ok {
		x.UseSecureConnection = &wrappers.BoolValue{Value: val}
	} else if x.UseSecureConnection == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.UseSecureConnection = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.UseSecureConnection != nil {
			x.UseSecureConnection = &wrappers.BoolValue{Value: defaultValues.UseSecureConnection.Value}
		}
	}
}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *BlockingConfig) loadFromEnv(prefix string, defaultValues *BlockingConfig) {
	if val, ok := getBoolEnv(prefix + "ENABLED"); ok {
		x.Enabled = &wrappers.BoolValue{Value: val}
	} else if x.Enabled == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Enabled = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.Enabled != nil {
			x.Enabled = &wrappers.BoolValue{Value: defaultValues.Enabled.Value}
		}
	}
	if val, ok := getBoolEnv(prefix + "DEBUG_LOG"); ok {
		x.DebugLog = &wrappers.BoolValue{Value: val}
	} else if x.DebugLog == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.DebugLog = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.DebugLog != nil {
			x.DebugLog = &wrappers.BoolValue{Value: defaultValues.DebugLog.Value}
		}
	}
	if x.Modsecurity == nil {
		x.Modsecurity = new(ModsecurityConfig)
	}
	if defaultValues == nil {
		x.Modsecurity.loadFromEnv(prefix+"MODSECURITY_", nil)
	} else {
		x.Modsecurity.loadFromEnv(prefix+"MODSECURITY_", defaultValues.Modsecurity)
	}

	if val, ok := getBoolEnv(prefix + "EVALUATE_BODY"); ok {
		x.EvaluateBody = &wrappers.BoolValue{Value: val}
	} else if x.EvaluateBody == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.EvaluateBody = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.EvaluateBody != nil {
			x.EvaluateBody = &wrappers.BoolValue{Value: defaultValues.EvaluateBody.Value}
		}
	}
	if x.RegionBlocking == nil {
		x.RegionBlocking = new(RegionBlockingConfig)
	}
	if defaultValues == nil {
		x.RegionBlocking.loadFromEnv(prefix+"REGION_BLOCKING_", nil)
	} else {
		x.RegionBlocking.loadFromEnv(prefix+"REGION_BLOCKING_", defaultValues.RegionBlocking)
	}

	if x.RemoteConfig == nil {
		x.RemoteConfig = new(RemoteConfig)
	}
	if defaultValues == nil {
		x.RemoteConfig.loadFromEnv(prefix+"REMOTE_CONFIG_", nil)
	} else {
		x.RemoteConfig.loadFromEnv(prefix+"REMOTE_CONFIG_", defaultValues.RemoteConfig)
	}

	if val, ok := getBoolEnv(prefix + "SKIP_INTERNAL_REQUEST"); ok {
		x.SkipInternalRequest = &wrappers.BoolValue{Value: val}
	} else if x.SkipInternalRequest == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.SkipInternalRequest = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.SkipInternalRequest != nil {
			x.SkipInternalRequest = &wrappers.BoolValue{Value: defaultValues.SkipInternalRequest.Value}
		}
	}
	if val, ok := getInt32Env(prefix + "RESPONSE_STATUS_CODE"); ok {
		x.ResponseStatusCode = &wrappers.Int32Value{Value: val}
	} else if x.ResponseStatusCode == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.ResponseStatusCode = new(wrappers.Int32Value)
		if defaultValues != nil && defaultValues.ResponseStatusCode != nil {
			x.ResponseStatusCode = &wrappers.Int32Value{Value: defaultValues.ResponseStatusCode.Value}
		}
	}
	if val, ok := getInt32Env(prefix + "MAX_RECURSION_DEPTH"); ok {
		x.MaxRecursionDepth = &wrappers.Int32Value{Value: val}
	} else if x.MaxRecursionDepth == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.MaxRecursionDepth = new(wrappers.Int32Value)
		if defaultValues != nil && defaultValues.MaxRecursionDepth != nil {
			x.MaxRecursionDepth = &wrappers.Int32Value{Value: defaultValues.MaxRecursionDepth.Value}
		}
	}
	if val, ok := getStringEnv(prefix + "RESPONSE_MESSAGE"); ok {
		x.ResponseMessage = &wrappers.StringValue{Value: val}
	} else if x.ResponseMessage == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.ResponseMessage = new(wrappers.StringValue)
		if defaultValues != nil && defaultValues.ResponseMessage != nil {
			x.ResponseMessage = &wrappers.StringValue{Value: defaultValues.ResponseMessage.Value}
		}
	}
	if x.EdgeDecisionService == nil {
		x.EdgeDecisionService = new(EdgeDecisionServiceConfig)
	}
	if defaultValues == nil {
		x.EdgeDecisionService.loadFromEnv(prefix+"EDGE_DECISION_SERVICE_", nil)
	} else {
		x.EdgeDecisionService.loadFromEnv(prefix+"EDGE_DECISION_SERVICE_", defaultValues.EdgeDecisionService)
	}

}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *ModsecurityConfig) loadFromEnv(prefix string, defaultValues *ModsecurityConfig) {
	if val, ok := getBoolEnv(prefix + "ENABLED"); ok {
		x.Enabled = &wrappers.BoolValue{Value: val}
	} else if x.Enabled == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Enabled = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.Enabled != nil {
			x.Enabled = &wrappers.BoolValue{Value: defaultValues.Enabled.Value}
		}
	}
}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *RegionBlockingConfig) loadFromEnv(prefix string, defaultValues *RegionBlockingConfig) {
	if val, ok := getBoolEnv(prefix + "ENABLED"); ok {
		x.Enabled = &wrappers.BoolValue{Value: val}
	} else if x.Enabled == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Enabled = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.Enabled != nil {
			x.Enabled = &wrappers.BoolValue{Value: defaultValues.Enabled.Value}
		}
	}
}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *RemoteConfig) loadFromEnv(prefix string, defaultValues *RemoteConfig) {
	if val, ok := getBoolEnv(prefix + "ENABLED"); ok {
		x.Enabled = &wrappers.BoolValue{Value: val}
	} else if x.Enabled == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Enabled = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.Enabled != nil {
			x.Enabled = &wrappers.BoolValue{Value: defaultValues.Enabled.Value}
		}
	}
	if val, ok := getStringEnv(prefix + "ENDPOINT"); ok {
		x.Endpoint = &wrappers.StringValue{Value: val}
	} else if x.Endpoint == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Endpoint = new(wrappers.StringValue)
		if defaultValues != nil && defaultValues.Endpoint != nil {
			x.Endpoint = &wrappers.StringValue{Value: defaultValues.Endpoint.Value}
		}
	}
	if val, ok := getInt32Env(prefix + "POLL_PERIOD_SECONDS"); ok {
		x.PollPeriodSeconds = &wrappers.Int32Value{Value: val}
	} else if x.PollPeriodSeconds == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.PollPeriodSeconds = new(wrappers.Int32Value)
		if defaultValues != nil && defaultValues.PollPeriodSeconds != nil {
			x.PollPeriodSeconds = &wrappers.Int32Value{Value: defaultValues.PollPeriodSeconds.Value}
		}
	}
	if val, ok := getStringEnv(prefix + "CERT_FILE"); ok {
		x.CertFile = &wrappers.StringValue{Value: val}
	} else if x.CertFile == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.CertFile = new(wrappers.StringValue)
		if defaultValues != nil && defaultValues.CertFile != nil {
			x.CertFile = &wrappers.StringValue{Value: defaultValues.CertFile.Value}
		}
	}
	if val, ok := getInt32Env(prefix + "GRPC_MAX_CALL_RECV_MSG_SIZE"); ok {
		x.GrpcMaxCallRecvMsgSize = &wrappers.Int32Value{Value: val}
	} else if x.GrpcMaxCallRecvMsgSize == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.GrpcMaxCallRecvMsgSize = new(wrappers.Int32Value)
		if defaultValues != nil && defaultValues.GrpcMaxCallRecvMsgSize != nil {
			x.GrpcMaxCallRecvMsgSize = &wrappers.Int32Value{Value: defaultValues.GrpcMaxCallRecvMsgSize.Value}
		}
	}
	if val, ok := getBoolEnv(prefix + "USE_SECURE_CONNECTION"); ok {
		x.UseSecureConnection = &wrappers.BoolValue{Value: val}
	} else if x.UseSecureConnection == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.UseSecureConnection = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.UseSecureConnection != nil {
			x.UseSecureConnection = &wrappers.BoolValue{Value: defaultValues.UseSecureConnection.Value}
		}
	}
}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *ApiDiscoveryConfig) loadFromEnv(prefix string, defaultValues *ApiDiscoveryConfig) {
	if val, ok := getBoolEnv(prefix + "ENABLED"); ok {
		x.Enabled = &wrappers.BoolValue{Value: val}
	} else if x.Enabled == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Enabled = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.Enabled != nil {
			x.Enabled = &wrappers.BoolValue{Value: defaultValues.Enabled.Value}
		}
	}
}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *SamplingConfig) loadFromEnv(prefix string, defaultValues *SamplingConfig) {
	if val, ok := getBoolEnv(prefix + "ENABLED"); ok {
		x.Enabled = &wrappers.BoolValue{Value: val}
	} else if x.Enabled == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Enabled = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.Enabled != nil {
			x.Enabled = &wrappers.BoolValue{Value: defaultValues.Enabled.Value}
		}
	}
	if x.DefaultRateLimitConfig == nil {
		x.DefaultRateLimitConfig = new(RateLimitConfig)
	}
	if defaultValues == nil {
		x.DefaultRateLimitConfig.loadFromEnv(prefix+"DEFAULT_RATE_LIMIT_CONFIG_", nil)
	} else {
		x.DefaultRateLimitConfig.loadFromEnv(prefix+"DEFAULT_RATE_LIMIT_CONFIG_", defaultValues.DefaultRateLimitConfig)
	}

}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *Javaagent) loadFromEnv(prefix string, defaultValues *Javaagent) {
	if val, ok := getBoolEnv(prefix + "IMPORT_JKS_CERTS"); ok {
		x.ImportJksCerts = &wrappers.BoolValue{Value: val}
	} else if x.ImportJksCerts == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.ImportJksCerts = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.ImportJksCerts != nil {
			x.ImportJksCerts = &wrappers.BoolValue{Value: defaultValues.ImportJksCerts.Value}
		}
	}
	if rawVals, ok := getArrayStringEnv(prefix + "FILTER_JAR_PATHS"); ok {
		for _, val := range rawVals {
			x.FilterJarPaths = append(x.FilterJarPaths, wrappers.String(val))
		}
	} else if len(x.FilterJarPaths) == 0 && defaultValues != nil && len(defaultValues.FilterJarPaths) > 0 {
		x.FilterJarPaths = defaultValues.FilterJarPaths
	}

}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *LogConfig) loadFromEnv(prefix string, defaultValues *LogConfig) {
	if rawVal, ok := getStringEnv(prefix + "LOG_MODE"); ok {
		x.LogMode = LogMode(LogMode_value[rawVal])
	} else if x.LogMode == LogMode(0) && defaultValues != nil && defaultValues.LogMode != LogMode(0) {
		x.LogMode = defaultValues.LogMode
	}

	if rawVal, ok := getStringEnv(prefix + "LOG_LEVEL"); ok {
		x.LogLevel = LogLevel(LogLevel_value[rawVal])
	} else if x.LogLevel == LogLevel(0) && defaultValues != nil && defaultValues.LogLevel != LogLevel(0) {
		x.LogLevel = defaultValues.LogLevel
	}

	if x.LogFile == nil {
		x.LogFile = new(LogFileConfig)
	}
	if defaultValues == nil {
		x.LogFile.loadFromEnv(prefix+"LOG_FILE_", nil)
	} else {
		x.LogFile.loadFromEnv(prefix+"LOG_FILE_", defaultValues.LogFile)
	}

}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *LogFileConfig) loadFromEnv(prefix string, defaultValues *LogFileConfig) {
	if val, ok := getInt32Env(prefix + "MAX_FILES"); ok {
		x.MaxFiles = &wrappers.Int32Value{Value: val}
	} else if x.MaxFiles == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.MaxFiles = new(wrappers.Int32Value)
		if defaultValues != nil && defaultValues.MaxFiles != nil {
			x.MaxFiles = &wrappers.Int32Value{Value: defaultValues.MaxFiles.Value}
		}
	}
	if val, ok := getInt32Env(prefix + "MAX_FILE_SIZE"); ok {
		x.MaxFileSize = &wrappers.Int32Value{Value: val}
	} else if x.MaxFileSize == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.MaxFileSize = new(wrappers.Int32Value)
		if defaultValues != nil && defaultValues.MaxFileSize != nil {
			x.MaxFileSize = &wrappers.Int32Value{Value: defaultValues.MaxFileSize.Value}
		}
	}
	if val, ok := getStringEnv(prefix + "FILE_PATH"); ok {
		x.FilePath = &wrappers.StringValue{Value: val}
	} else if x.FilePath == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.FilePath = new(wrappers.StringValue)
		if defaultValues != nil && defaultValues.FilePath != nil {
			x.FilePath = &wrappers.StringValue{Value: defaultValues.FilePath.Value}
		}
	}
}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *MetricsLogConfig) loadFromEnv(prefix string, defaultValues *MetricsLogConfig) {
	if val, ok := getBoolEnv(prefix + "ENABLED"); ok {
		x.Enabled = &wrappers.BoolValue{Value: val}
	} else if x.Enabled == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Enabled = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.Enabled != nil {
			x.Enabled = &wrappers.BoolValue{Value: defaultValues.Enabled.Value}
		}
	}
	if val, ok := getStringEnv(prefix + "FREQUENCY"); ok {
		x.Frequency = &wrappers.StringValue{Value: val}
	} else if x.Frequency == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Frequency = new(wrappers.StringValue)
		if defaultValues != nil && defaultValues.Frequency != nil {
			x.Frequency = &wrappers.StringValue{Value: defaultValues.Frequency.Value}
		}
	}
}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *EndpointMetricsConfig) loadFromEnv(prefix string, defaultValues *EndpointMetricsConfig) {
	if val, ok := getBoolEnv(prefix + "ENABLED"); ok {
		x.Enabled = &wrappers.BoolValue{Value: val}
	} else if x.Enabled == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Enabled = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.Enabled != nil {
			x.Enabled = &wrappers.BoolValue{Value: defaultValues.Enabled.Value}
		}
	}
	if val, ok := getInt32Env(prefix + "MAX_ENDPOINTS"); ok {
		x.MaxEndpoints = &wrappers.Int32Value{Value: val}
	} else if x.MaxEndpoints == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.MaxEndpoints = new(wrappers.Int32Value)
		if defaultValues != nil && defaultValues.MaxEndpoints != nil {
			x.MaxEndpoints = &wrappers.Int32Value{Value: defaultValues.MaxEndpoints.Value}
		}
	}
	if x.Logging == nil {
		x.Logging = new(MetricsLogConfig)
	}
	if defaultValues == nil {
		x.Logging.loadFromEnv(prefix+"LOGGING_", nil)
	} else {
		x.Logging.loadFromEnv(prefix+"LOGGING_", defaultValues.Logging)
	}

}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *MetricsConfig) loadFromEnv(prefix string, defaultValues *MetricsConfig) {
	if val, ok := getBoolEnv(prefix + "ENABLED"); ok {
		x.Enabled = &wrappers.BoolValue{Value: val}
	} else if x.Enabled == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Enabled = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.Enabled != nil {
			x.Enabled = &wrappers.BoolValue{Value: defaultValues.Enabled.Value}
		}
	}
	if x.EndpointConfig == nil {
		x.EndpointConfig = new(EndpointMetricsConfig)
	}
	if defaultValues == nil {
		x.EndpointConfig.loadFromEnv(prefix+"ENDPOINT_CONFIG_", nil)
	} else {
		x.EndpointConfig.loadFromEnv(prefix+"ENDPOINT_CONFIG_", defaultValues.EndpointConfig)
	}

	if x.Logging == nil {
		x.Logging = new(MetricsLogConfig)
	}
	if defaultValues == nil {
		x.Logging.loadFromEnv(prefix+"LOGGING_", nil)
	} else {
		x.Logging.loadFromEnv(prefix+"LOGGING_", defaultValues.Logging)
	}

	if x.Exporter == nil {
		x.Exporter = new(MetricsExporterConfig)
	}
	if defaultValues == nil {
		x.Exporter.loadFromEnv(prefix+"EXPORTER_", nil)
	} else {
		x.Exporter.loadFromEnv(prefix+"EXPORTER_", defaultValues.Exporter)
	}

	if val, ok := getInt32Env(prefix + "MAX_QUEUE_SIZE"); ok {
		x.MaxQueueSize = &wrappers.Int32Value{Value: val}
	} else if x.MaxQueueSize == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.MaxQueueSize = new(wrappers.Int32Value)
		if defaultValues != nil && defaultValues.MaxQueueSize != nil {
			x.MaxQueueSize = &wrappers.Int32Value{Value: defaultValues.MaxQueueSize.Value}
		}
	}
}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *RateLimitConfig) loadFromEnv(prefix string, defaultValues *RateLimitConfig) {
	if val, ok := getBoolEnv(prefix + "ENABLED"); ok {
		x.Enabled = &wrappers.BoolValue{Value: val}
	} else if x.Enabled == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Enabled = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.Enabled != nil {
			x.Enabled = &wrappers.BoolValue{Value: defaultValues.Enabled.Value}
		}
	}
	if val, ok := getInt64Env(prefix + "MAX_COUNT_GLOBAL"); ok {
		x.MaxCountGlobal = &wrappers.Int64Value{Value: val}
	} else if x.MaxCountGlobal == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.MaxCountGlobal = new(wrappers.Int64Value)
		if defaultValues != nil && defaultValues.MaxCountGlobal != nil {
			x.MaxCountGlobal = &wrappers.Int64Value{Value: defaultValues.MaxCountGlobal.Value}
		}
	}
	if val, ok := getInt64Env(prefix + "MAX_COUNT_PER_ENDPOINT"); ok {
		x.MaxCountPerEndpoint = &wrappers.Int64Value{Value: val}
	} else if x.MaxCountPerEndpoint == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.MaxCountPerEndpoint = new(wrappers.Int64Value)
		if defaultValues != nil && defaultValues.MaxCountPerEndpoint != nil {
			x.MaxCountPerEndpoint = &wrappers.Int64Value{Value: defaultValues.MaxCountPerEndpoint.Value}
		}
	}
	if val, ok := getStringEnv(prefix + "REFRESH_PERIOD"); ok {
		x.RefreshPeriod = &wrappers.StringValue{Value: val}
	} else if x.RefreshPeriod == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.RefreshPeriod = new(wrappers.StringValue)
		if defaultValues != nil && defaultValues.RefreshPeriod != nil {
			x.RefreshPeriod = &wrappers.StringValue{Value: defaultValues.RefreshPeriod.Value}
		}
	}
	if val, ok := getStringEnv(prefix + "VALUE_EXPIRATION_PERIOD"); ok {
		x.ValueExpirationPeriod = &wrappers.StringValue{Value: val}
	} else if x.ValueExpirationPeriod == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.ValueExpirationPeriod = new(wrappers.StringValue)
		if defaultValues != nil && defaultValues.ValueExpirationPeriod != nil {
			x.ValueExpirationPeriod = &wrappers.StringValue{Value: defaultValues.ValueExpirationPeriod.Value}
		}
	}
	if rawVal, ok := getStringEnv(prefix + "SPAN_TYPE"); ok {
		x.SpanType = SpanType(SpanType_value[rawVal])
	} else if x.SpanType == SpanType(0) && defaultValues != nil && defaultValues.SpanType != SpanType(0) {
		x.SpanType = defaultValues.SpanType
	}

}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *EdgeDecisionServiceConfig) loadFromEnv(prefix string, defaultValues *EdgeDecisionServiceConfig) {
	if val, ok := getBoolEnv(prefix + "ENABLED"); ok {
		x.Enabled = &wrappers.BoolValue{Value: val}
	} else if x.Enabled == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Enabled = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.Enabled != nil {
			x.Enabled = &wrappers.BoolValue{Value: defaultValues.Enabled.Value}
		}
	}
	if val, ok := getStringEnv(prefix + "ENDPOINT"); ok {
		x.Endpoint = &wrappers.StringValue{Value: val}
	} else if x.Endpoint == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Endpoint = new(wrappers.StringValue)
		if defaultValues != nil && defaultValues.Endpoint != nil {
			x.Endpoint = &wrappers.StringValue{Value: defaultValues.Endpoint.Value}
		}
	}
	if val, ok := getInt32Env(prefix + "TIMEOUT_MS"); ok {
		x.TimeoutMs = &wrappers.Int32Value{Value: val}
	} else if x.TimeoutMs == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.TimeoutMs = new(wrappers.Int32Value)
		if defaultValues != nil && defaultValues.TimeoutMs != nil {
			x.TimeoutMs = &wrappers.Int32Value{Value: defaultValues.TimeoutMs.Value}
		}
	}
	if rawVals, ok := getArrayStringEnv(prefix + "INCLUDE_PATH_REGEXES"); ok {
		for _, val := range rawVals {
			x.IncludePathRegexes = append(x.IncludePathRegexes, wrappers.String(val))
		}
	} else if len(x.IncludePathRegexes) == 0 && defaultValues != nil && len(defaultValues.IncludePathRegexes) > 0 {
		x.IncludePathRegexes = defaultValues.IncludePathRegexes
	}

	if rawVals, ok := getArrayStringEnv(prefix + "EXCLUDE_PATH_REGEXES"); ok {
		for _, val := range rawVals {
			x.ExcludePathRegexes = append(x.ExcludePathRegexes, wrappers.String(val))
		}
	} else if len(x.ExcludePathRegexes) == 0 && defaultValues != nil && len(defaultValues.ExcludePathRegexes) > 0 {
		x.ExcludePathRegexes = defaultValues.ExcludePathRegexes
	}

}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *Message) loadFromEnv(prefix string, defaultValues *Message) {
	if val, ok := getBoolEnv(prefix + "REQUEST"); ok {
		x.Request = &wrappers.BoolValue{Value: val}
	} else if x.Request == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Request = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.Request != nil {
			x.Request = &wrappers.BoolValue{Value: defaultValues.Request.Value}
		}
	}
	if val, ok := getBoolEnv(prefix + "RESPONSE"); ok {
		x.Response = &wrappers.BoolValue{Value: val}
	} else if x.Response == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Response = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.Response != nil {
			x.Response = &wrappers.BoolValue{Value: defaultValues.Response.Value}
		}
	}
}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *DataCapture) loadFromEnv(prefix string, defaultValues *DataCapture) {
	if x.HttpHeaders == nil {
		x.HttpHeaders = new(Message)
	}
	if defaultValues == nil {
		x.HttpHeaders.loadFromEnv(prefix+"HTTP_HEADERS_", nil)
	} else {
		x.HttpHeaders.loadFromEnv(prefix+"HTTP_HEADERS_", defaultValues.HttpHeaders)
	}

	if x.HttpBody == nil {
		x.HttpBody = new(Message)
	}
	if defaultValues == nil {
		x.HttpBody.loadFromEnv(prefix+"HTTP_BODY_", nil)
	} else {
		x.HttpBody.loadFromEnv(prefix+"HTTP_BODY_", defaultValues.HttpBody)
	}

	if x.RpcMetadata == nil {
		x.RpcMetadata = new(Message)
	}
	if defaultValues == nil {
		x.RpcMetadata.loadFromEnv(prefix+"RPC_METADATA_", nil)
	} else {
		x.RpcMetadata.loadFromEnv(prefix+"RPC_METADATA_", defaultValues.RpcMetadata)
	}

	if x.RpcBody == nil {
		x.RpcBody = new(Message)
	}
	if defaultValues == nil {
		x.RpcBody.loadFromEnv(prefix+"RPC_BODY_", nil)
	} else {
		x.RpcBody.loadFromEnv(prefix+"RPC_BODY_", defaultValues.RpcBody)
	}

	if val, ok := getInt32Env(prefix + "BODY_MAX_SIZE_BYTES"); ok {
		x.BodyMaxSizeBytes = &wrappers.Int32Value{Value: val}
	} else if x.BodyMaxSizeBytes == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.BodyMaxSizeBytes = new(wrappers.Int32Value)
		if defaultValues != nil && defaultValues.BodyMaxSizeBytes != nil {
			x.BodyMaxSizeBytes = &wrappers.Int32Value{Value: defaultValues.BodyMaxSizeBytes.Value}
		}
	}
	if val, ok := getInt32Env(prefix + "BODY_MAX_PROCESSING_SIZE_BYTES"); ok {
		x.BodyMaxProcessingSizeBytes = &wrappers.Int32Value{Value: val}
	} else if x.BodyMaxProcessingSizeBytes == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.BodyMaxProcessingSizeBytes = new(wrappers.Int32Value)
		if defaultValues != nil && defaultValues.BodyMaxProcessingSizeBytes != nil {
			x.BodyMaxProcessingSizeBytes = &wrappers.Int32Value{Value: defaultValues.BodyMaxProcessingSizeBytes.Value}
		}
	}
	if rawVals, ok := getArrayStringEnv(prefix + "ALLOWED_CONTENT_TYPES"); ok {
		for _, val := range rawVals {
			x.AllowedContentTypes = append(x.AllowedContentTypes, wrappers.String(val))
		}
	} else if len(x.AllowedContentTypes) == 0 && defaultValues != nil && len(defaultValues.AllowedContentTypes) > 0 {
		x.AllowedContentTypes = defaultValues.AllowedContentTypes
	}

}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *GoAgent) loadFromEnv(prefix string, defaultValues *GoAgent) {
	if val, ok := getBoolEnv(prefix + "USE_CUSTOM_BSP"); ok {
		x.UseCustomBsp = &wrappers.BoolValue{Value: val}
	} else if x.UseCustomBsp == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.UseCustomBsp = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.UseCustomBsp != nil {
			x.UseCustomBsp = &wrappers.BoolValue{Value: defaultValues.UseCustomBsp.Value}
		}
	}
}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *Telemetry) loadFromEnv(prefix string, defaultValues *Telemetry) {
	if val, ok := getBoolEnv(prefix + "STARTUP_SPAN_ENABLED"); ok {
		x.StartupSpanEnabled = &wrappers.BoolValue{Value: val}
	} else if x.StartupSpanEnabled == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.StartupSpanEnabled = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.StartupSpanEnabled != nil {
			x.StartupSpanEnabled = &wrappers.BoolValue{Value: defaultValues.StartupSpanEnabled.Value}
		}
	}
	if val, ok := getBoolEnv(prefix + "METRICS_ENABLED"); ok {
		x.MetricsEnabled = &wrappers.BoolValue{Value: val}
	} else if x.MetricsEnabled == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.MetricsEnabled = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.MetricsEnabled != nil {
			x.MetricsEnabled = &wrappers.BoolValue{Value: defaultValues.MetricsEnabled.Value}
		}
	}
}

// loadFromEnv loads the data from env vars, defaults and makes sure all values are initialized.
func (x *MetricsExporterConfig) loadFromEnv(prefix string, defaultValues *MetricsExporterConfig) {
	if val, ok := getBoolEnv(prefix + "ENABLED"); ok {
		x.Enabled = &wrappers.BoolValue{Value: val}
	} else if x.Enabled == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.Enabled = new(wrappers.BoolValue)
		if defaultValues != nil && defaultValues.Enabled != nil {
			x.Enabled = &wrappers.BoolValue{Value: defaultValues.Enabled.Value}
		}
	}
	if val, ok := getInt32Env(prefix + "EXPORT_INTERVAL_MS"); ok {
		x.ExportIntervalMs = &wrappers.Int32Value{Value: val}
	} else if x.ExportIntervalMs == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.ExportIntervalMs = new(wrappers.Int32Value)
		if defaultValues != nil && defaultValues.ExportIntervalMs != nil {
			x.ExportIntervalMs = &wrappers.Int32Value{Value: defaultValues.ExportIntervalMs.Value}
		}
	}
	if val, ok := getInt32Env(prefix + "EXPORT_TIMEOUT_MS"); ok {
		x.ExportTimeoutMs = &wrappers.Int32Value{Value: val}
	} else if x.ExportTimeoutMs == nil {
		// when there is no value to set we still prefer to initialize the variable to avoid
		// `nil` checks in the consumers.
		x.ExportTimeoutMs = new(wrappers.Int32Value)
		if defaultValues != nil && defaultValues.ExportTimeoutMs != nil {
			x.ExportTimeoutMs = &wrappers.Int32Value{Value: defaultValues.ExportTimeoutMs.Value}
		}
	}
}
